import router from '@ohos.router';
import { image } from '@kit.ImageKit';
import { getNativeModule, initHarmonyDesk, type VideoFrame } from '../native/HarmonyDeskNative';

@Entry
@Component
struct Session {
  @State viewOnly: boolean = false;
  @State hdQuality: boolean = true;
  @State showToolbar: boolean = false;
  @State deskId: string = '';
  @State password: string = '';
  @State isConnected: boolean = false;
  @State connectionStatus: string = 'æœªè¿æ¥';
  @State connectionStep: string = '';
  @State connectionLogs: string[] = [];
  @State errorMessage: string = '';
  @State pixelMap: image.PixelMap | null = null;
  @State frameRate: number = 20;
  @State showMenu: boolean = false;
  @State deviceName: string = '';
  @State ballX: number = 300;
  @State ballY: number = 500;
  @State ballOffsetX: number = 0;
  @State ballOffsetY: number = 0;
  @State isDragging: boolean = false;
  @State isHalfHidden: boolean = true;

  private videoTimer: number = -1;
  private screenWidth: number = 360;
  private screenHeight: number = 780;
  private ballSize: number = 48;

  async aboutToAppear() {
    console.info('[Session] aboutToAppear called');
    
    try {
      await initHarmonyDesk();
      console.info('[Session] initHarmonyDesk completed');
    } catch (error) {
      console.error('[Session] initHarmonyDesk failed:', error);
    }

    // è·å–è·¯ç”±å‚æ•° - å°è¯•å¤šç§æ–¹å¼
    let params: Record<string, Object> | null = null;
    
    try {
      params = router.getParams() as Record<string, Object> | null;
      console.info('[Session] router.getParams() result:', params ? JSON.stringify(params) : 'null');
    } catch (error) {
      console.error('[Session] router.getParams() error:', error);
    }
    
    // å¦‚æœ getParams è¿”å› nullï¼Œå°è¯•å»¶è¿Ÿè·å–
    if (!params) {
      console.warn('[Session] Params is null, waiting 100ms and retry...');
      await new Promise<void>((resolve) => {
        setTimeout(() => resolve(), 100);
      });
      try {
        params = router.getParams() as Record<string, Object> | null;
        console.info('[Session] Retry getParams() result:', params ? JSON.stringify(params) : 'null');
      } catch (error) {
        console.error('[Session] Retry getParams() error:', error);
      }
    }
    
    if (params) {
      // å®‰å…¨åœ°è·å–å‚æ•°å€¼
      this.deskId = String(params.id || params['id'] || '').trim();
      this.password = String(params.password || params['password'] || '').trim();
      this.deviceName = String(params.name || params['name'] || '').trim();
      this.viewOnly = String(params.viewOnly || params['viewOnly'] || '0') === '1' || params.viewOnly === true;
      
      console.info('[Session] Parsed params - deskId:', this.deskId, 'password:', this.password ? '***' : '(empty)', 'name:', this.deviceName);
    } else {
      console.warn('[Session] No params received from router');
      this.errorMessage = 'ç¼ºå°‘è®¾å¤‡ ID å‚æ•°';
      this.connectionStatus = 'å‚æ•°é”™è¯¯';
    }

    // åˆå§‹åŒ–æ‚¬æµ®çƒä½ç½®ï¼ˆå³ä¸‹è§’ï¼ŒåŠéšè—ï¼‰
    const hideOffset = this.ballSize * 0.4;
    this.ballX = this.screenWidth - this.ballSize + hideOffset;
    this.ballY = this.screenHeight - this.ballSize - 100;
    this.isHalfHidden = true;

    // å¦‚æœæœ‰è®¾å¤‡ IDï¼Œå¼€å§‹è¿æ¥
    if (this.deskId && this.deskId.trim().length > 0) {
      console.info('[Session] Starting connection to:', this.deskId);
      // å»¶è¿Ÿä¸€ä¸‹ç¡®ä¿UIæ›´æ–°
      await new Promise<void>((resolve) => {
        setTimeout(() => resolve(), 200);
      });
      this.connect();
    } else {
      console.warn('[Session] No deskId provided, cannot connect. Current deskId:', this.deskId);
      this.errorMessage = 'è®¾å¤‡ ID ä¸ºç©ºï¼Œæ— æ³•è¿æ¥';
      this.connectionStatus = 'å‚æ•°é”™è¯¯';
    }
    
    console.info('[Session] aboutToAppear completed');
  }

  async aboutToDisappear() {
    if (this.videoTimer !== -1) {
      clearInterval(this.videoTimer);
      this.videoTimer = -1;
    }
    if (this.pixelMap) {
      this.pixelMap.release();
      this.pixelMap = null;
    }
    await this.disconnect();
  }

  build() {
    Stack({ alignContent: Alignment.BottomEnd }) {
      // å…¨å±è¿œç¨‹ç”»é¢
      Column() {
        if (this.pixelMap) {
          Image(this.pixelMap)
            .objectFit(ImageFit.Cover)
            .width('100%')
            .height('100%')
        } else {
          Scroll() {
            Column({ space: 16 }) {
              // è¿æ¥çŠ¶æ€å›¾æ ‡
              if (this.connectionStatus === 'æ­£åœ¨è¿æ¥...') {
                Column({ space: 8 }) {
                  Text('â³')
                    .fontSize(48)
                  Text(this.connectionStep || 'æ­£åœ¨è¿æ¥...')
                    .fontSize(16)
                    .fontWeight(FontWeight.Medium)
                    .fontColor($r('app.color.text_primary'))
                }
              } else if (this.connectionStatus === 'è¿æ¥å¤±è´¥' || this.connectionStatus === 'è¿æ¥é”™è¯¯' || this.connectionStatus === 'å‚æ•°é”™è¯¯') {
                Column({ space: 8 }) {
                  Text('âŒ')
                    .fontSize(48)
                  Text(this.connectionStatus)
                    .fontSize(16)
                    .fontWeight(FontWeight.Medium)
                    .fontColor($r('app.color.status_offline'))
                }
              } else {
                Column({ space: 8 }) {
                  Text('ğŸ–¥ï¸')
                    .fontSize(48)
                  Text(this.connectionStatus === 'æœªè¿æ¥' ? 'å‡†å¤‡è¿æ¥' : this.connectionStatus)
                    .fontSize(16)
                    .fontWeight(FontWeight.Medium)
                    .fontColor($r('app.color.text_primary'))
                }
              }

              // è®¾å¤‡ä¿¡æ¯
              Column({ space: 8 }) {
                Text(`è®¾å¤‡ ID: ${this.deskId || '(ç©º)'}`)
                  .fontSize(14)
                  .fontColor(this.deskId ? $r('app.color.text_secondary') : $r('app.color.status_offline'))
                if (this.deviceName) {
                  Text(`è®¾å¤‡åç§°: ${this.deviceName}`)
                    .fontSize(14)
                    .fontColor($r('app.color.text_secondary'))
                }
                // è°ƒè¯•ä¿¡æ¯
                Text(`è¿æ¥çŠ¶æ€: ${this.connectionStatus}`)
                  .fontSize(12)
                  .fontColor($r('app.color.text_muted'))
                  .margin({ top: 4 })
              }
              .padding(16)
              .borderRadius(12)
              .backgroundColor($r('app.color.card_background'))
              .width('100%')

              // è¿æ¥æ—¥å¿—
              if (this.connectionLogs.length > 0) {
                Column({ space: 8 }) {
                  Text('è¿æ¥æ—¥å¿—')
                    .fontSize(14)
                    .fontWeight(FontWeight.Medium)
                    .fontColor($r('app.color.text_primary'))

                  Column({ space: 4 }) {
                    ForEach(this.connectionLogs, (log: string, index: number) => {
                      Text(log)
                        .fontSize(12)
                        .fontColor(log.includes('âœ“') ? $r('app.color.status_online') :
                                   log.includes('âœ—') ? $r('app.color.status_offline') :
                                   $r('app.color.text_secondary'))
                        .width('100%')
                    }, (log: string, index: number) => `${index}_${log}`)
                  }
                  .width('100%')
                  .padding(12)
                  .borderRadius(8)
                  .backgroundColor('#F5F5F5')
                }
                .padding(16)
                .borderRadius(12)
                .backgroundColor($r('app.color.card_background'))
                .width('100%')
              }

              // é”™è¯¯ä¿¡æ¯
              if (this.errorMessage) {
                Column({ space: 8 }) {
                  Text('é”™è¯¯ä¿¡æ¯')
                    .fontSize(14)
                    .fontWeight(FontWeight.Medium)
                    .fontColor($r('app.color.status_offline'))
                  Text(this.errorMessage)
                    .fontSize(13)
                    .fontColor($r('app.color.text_secondary'))
                }
                .padding(16)
                .borderRadius(12)
                .backgroundColor('#FFF3F3')
                .width('100%')
              }

              // é‡è¯•æŒ‰é’®
              if (this.connectionStatus === 'è¿æ¥å¤±è´¥' || this.connectionStatus === 'è¿æ¥é”™è¯¯') {
                Button('é‡æ–°è¿æ¥')
                  .width('100%')
                  .type(ButtonType.Capsule)
                  .height(44)
                  .borderRadius(22)
                  .fontColor($r('app.color.text_on_accent'))
                  .backgroundColor($r('app.color.accent'))
                  .onClick(() => {
                    this.connect();
                  })
              }

              // è¿”å›æŒ‰é’®
              Button('è¿”å›')
                .width('100%')
                .type(ButtonType.Capsule)
                .height(44)
                .borderRadius(22)
                .fontColor($r('app.color.text_primary'))
                .backgroundColor($r('app.color.card_background'))
                .onClick(() => {
                  router.back();
                })
            }
            .padding({ left: 16, right: 16, top: 20, bottom: 20 })
          }
          .width('100%')
          .height('100%')
          .backgroundColor($r('app.color.app_background_top'))
        }
      }
      .width('100%')
      .height('100%')
      .onAreaChange((area: Area) => {
        this.screenWidth = Number(area.width) as number;
        this.screenHeight = Number(area.height) as number;
        // æ›´æ–°æ‚¬æµ®çƒä½ç½®åˆ°å³ä¸‹è§’ï¼ˆåŠéšè—ï¼‰
        if (!this.isDragging && !this.showMenu && this.isHalfHidden) {
          const hideOffset = this.ballSize * 0.4;
          this.ballX = this.screenWidth - this.ballSize + hideOffset;
          this.ballY = this.screenHeight - this.ballSize - 100;
        }
      })

      // é¡¶éƒ¨çŠ¶æ€æ ï¼ˆè¿æ¥åæ˜¾ç¤ºï¼‰
      if (this.isConnected && this.showToolbar) {
        Row({ space: 12 }) {
          Button()
            .type(ButtonType.Circle)
            .width(36)
            .height(36)
            .backgroundColor($r('app.color.card_background'))
            .onClick(() => {
              router.back();
            })
          .stateEffect(true)

          Column({ space: 2 }) {
            Text(this.deviceName || this.deskId)
              .fontSize(16)
              .fontWeight(FontWeight.Medium)
              .fontColor($r('app.color.text_primary'))
            Text('å·²è¿æ¥')
              .fontSize(12)
              .fontColor($r('app.color.status_online'))
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Start)

          Button('æ–­å¼€')
            .type(ButtonType.Capsule)
            .fontSize(13)
            .height(32)
            .fontColor($r('app.color.text_on_accent'))
            .backgroundColor($r('app.color.accent'))
            .onClick(() => {
              this.disconnect();
              router.back();
            })
        }
        .width('100%')
        .padding({ left: 16, right: 16, top: 12, bottom: 12 })
        .backgroundColor($r('app.color.card_background'))
        .shadow({ radius: 8, color: 'rgba(0, 0, 0, 0.1)' })
      }

      // æ‚¬æµ®çƒ
      if (this.isConnected) {
        Stack() {
          if (!this.showMenu) {
            // æ‚¬æµ®çƒæŒ‰é’® - å®Œç¾çš„åœ†å½¢è®¾è®¡
            Column() {
              // æ‚¬æµ®çƒå›¾æ ‡
              Text('âš™ï¸')
                .fontSize(24)
                .fontColor(Color.White)
            }
            .width(this.ballSize)
            .height(this.ballSize)
            .borderRadius(this.ballSize / 2)
            .backgroundColor($r('app.color.accent'))
            .position({ x: this.ballX, y: this.ballY })
            .shadow({ radius: 16, color: 'rgba(0, 0, 0, 0.4)', offsetY: 4 })
            .animation({ duration: 200, curve: Curve.EaseOut })
            .gesture(
              // ç»„åˆæ‰‹åŠ¿ï¼šå¯ä»¥ç›´æ¥æ‹–æ‹½ï¼ŒçŸ­æŒ‰ç‚¹å‡»
              GestureGroup(GestureMode.Exclusive,
                // æ‹–åŠ¨æ‰‹åŠ¿ - ç›´æ¥æ‹–æ‹½ï¼Œä¸éœ€è¦é•¿æŒ‰
                PanGesture({ direction: PanDirection.All })
                  .onActionStart((event: GestureEvent) => {
                    // è®°å½•èµ·å§‹åç§»
                    this.ballOffsetX = event.fingerList[0].localX - this.ballX;
                    this.ballOffsetY = event.fingerList[0].localY - this.ballY;
                    this.isDragging = true;
                    this.isHalfHidden = false;
                  })
                  .onActionUpdate((event: GestureEvent) => {
                    const x = event.fingerList[0].localX;
                    const y = event.fingerList[0].localY;
                    this.ballX = x - this.ballOffsetX;
                    this.ballY = y - this.ballOffsetY;
                    this.constrainBallPosition();
                  })
                  .onActionEnd(() => {
                    this.isDragging = false;
                    this.snapToEdge();
                  }),
                // ç‚¹å‡»æ‰‹åŠ¿ - å¿«é€Ÿç‚¹å‡»æ‰“å¼€èœå•
                TapGesture()
                  .onAction(() => {
                    this.showMenu = true;
                    this.isHalfHidden = false;
                  })
              )
            )
            // æ‹–æ‹½æ—¶çš„è§†è§‰åé¦ˆ
            .scale({ x: this.isDragging ? 1.15 : 1, y: this.isDragging ? 1.15 : 1 })
            .opacity(this.isHalfHidden ? 0.6 : 1)
          } else {
            // èœå•é¢æ¿ - æ˜¾ç¤ºåœ¨æ‚¬æµ®çƒé™„è¿‘
            Column({ space: 12 }) {
              // åŠŸèƒ½æŒ‰é’®åˆ—è¡¨
              Column({ space: 8 }) {
                this.menuButton('âŒ¨ï¸ é”®ç›˜', () => {
                  // é”®ç›˜åŠŸèƒ½
                })
                this.menuButton(this.viewOnly ? 'ğŸ‘ï¸ åªè¯»' : 'âœï¸ æ§åˆ¶', () => {
                  this.viewOnly = !this.viewOnly;
                })
                this.menuButton(this.hdQuality ? 'ğŸ¨ é«˜æ¸…' : 'ğŸ¨ æ ‡æ¸…', () => {
                  this.hdQuality = !this.hdQuality;
                })
                this.menuButton('ğŸ”’ é”å±', () => {
                  // é”å±åŠŸèƒ½
                })
                this.menuButton('âŒ¨ï¸ Ctrl+Alt+Del', () => {
                  // å‘é€å¿«æ·é”®
                })
                this.menuButton('ğŸ”Œ æ–­å¼€è¿æ¥', () => {
                  this.disconnect();
                  router.back();
                }, true)
              }
              .padding(12)
              .borderRadius(16)
              .backgroundColor($r('app.color.card_background'))
              .shadow({ radius: 16, color: 'rgba(0, 0, 0, 0.25)', offsetY: 4 })
              .width(140)

              // å…³é—­èœå•æŒ‰é’®
              Column() {
                Text('âœ•')
                  .fontSize(20)
                  .fontColor($r('app.color.text_secondary'))
                  .fontWeight(FontWeight.Medium)
              }
              .width(44)
              .height(44)
              .borderRadius(22)
              .backgroundColor($r('app.color.card_background'))
              .justifyContent(FlexAlign.Center)
              .shadow({ radius: 8, color: 'rgba(0, 0, 0, 0.15)' })
              .onClick(() => {
                this.showMenu = false;
                this.snapToEdge();
              })
            }
            .position({
              x: this.ballX > this.screenWidth / 2 ? this.ballX - 150 : this.ballX + this.ballSize + 10,
              y: Math.max(0, Math.min(this.ballY, this.screenHeight - 400))
            })
            .animation({ duration: 250, curve: Curve.FastOutSlowIn })
          }
        }
        .width('100%')
        .height('100%')
      }

      // è¿æ¥æç¤ºï¼ˆæœªè¿æ¥æ—¶æ˜¾ç¤ºï¼‰
      if (!this.isConnected) {
        Column({ space: 12 }) {
          Text('æ­£åœ¨è¿æ¥...')
            .fontSize(16)
            .fontColor($r('app.color.text_primary'))
          if (this.errorMessage) {
            Text(this.errorMessage)
              .fontSize(14)
              .fontColor($r('app.color.status_offline'))
            Button('è¿”å›')
              .type(ButtonType.Capsule)
              .onClick(() => {
                router.back();
              })
          }
        }
        .padding(20)
        .borderRadius(16)
        .backgroundColor($r('app.color.card_background'))
        .margin({ bottom: 100 })
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor($r('app.color.app_background_top'))
  }

  @Builder
  menuButton(label: string, action: () => void, isDanger: boolean = false) {
    Column() {
      Text(label)
        .fontSize(14)
        .fontColor(isDanger ? '#E53935' : $r('app.color.text_primary'))
        .fontWeight(FontWeight.Medium)
    }
    .width('100%')
    .height(44)
    .borderRadius(10)
    .backgroundColor(isDanger ? '#FFEBEE' : $r('app.color.input_background'))
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .onClick(action)
  }

  // é™åˆ¶æ‚¬æµ®çƒåœ¨å±å¹•èŒƒå›´å†…
  private constrainBallPosition(): void {
    const margin = 0;
    if (this.ballX < margin) {
      this.ballX = margin;
    }
    if (this.ballX > this.screenWidth - this.ballSize - margin) {
      this.ballX = this.screenWidth - this.ballSize - margin;
    }
    if (this.ballY < margin) {
      this.ballY = margin;
    }
    if (this.ballY > this.screenHeight - this.ballSize - margin) {
      this.ballY = this.screenHeight - this.ballSize - margin;
    }
  }

  // å¸é™„åˆ°è¾¹ç¼˜å¹¶åŠéšè—
  private snapToEdge(): void {
    const threshold = this.screenWidth / 2;
    const hideOffset = this.ballSize * 0.4; // åŠéšè—åç§»é‡

    // åˆ¤æ–­åº”è¯¥å¸é™„åˆ°å“ªè¾¹
    if (this.ballX + this.ballSize / 2 < threshold) {
      // é å·¦è¾¹ç¼˜
      this.ballX = -hideOffset;
    } else {
      // é å³è¾¹ç¼˜
      this.ballX = this.screenWidth - this.ballSize + hideOffset;
    }

    this.isHalfHidden = true;

    // ä¸Šä¸‹è¾¹ç•Œ - ä¸åšåŠéšè—
    if (this.ballY < 0) {
      this.ballY = 0;
    }
    if (this.ballY > this.screenHeight - this.ballSize) {
      this.ballY = this.screenHeight - this.ballSize;
    }
  }

  private addLog(message: string): void {
    const timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false });
    this.connectionLogs.push(`[${timestamp}] ${message}`);
    console.log(`[Session] ${message}`);
  }

  private async connect(): Promise<void> {
    // å…ˆæ£€æŸ¥è®¾å¤‡ ID
    if (!this.deskId || this.deskId.trim().length === 0) {
      this.errorMessage = 'ç¼ºå°‘è®¾å¤‡ ID';
      this.connectionStatus = 'å‚æ•°é”™è¯¯';
      console.error('[Session] Cannot connect: deskId is empty');
      return;
    }

    // é‡ç½®çŠ¶æ€
    this.connectionLogs = [];
    this.connectionStep = '';
    this.errorMessage = '';

    try {
      this.addLog(`å¼€å§‹è¿æ¥åˆ°: ${this.deskId}`);
      // ç«‹å³æ›´æ–°çŠ¶æ€ï¼Œç¡®ä¿UIèƒ½çœ‹åˆ°
      this.connectionStatus = 'æ­£åœ¨è¿æ¥...';
      this.connectionStep = 'åˆå§‹åŒ–åŸç”Ÿæ¨¡å—';
      
      // å¼ºåˆ¶è§¦å‘UIæ›´æ–°
      await new Promise<void>((resolve) => {
        setTimeout(() => resolve(), 10);
      });

      // ç¡®ä¿UIçŠ¶æ€æ›´æ–°å…ˆè¢«å¤„ç†
      await new Promise<void>((resolve) => {
        setTimeout(() => resolve(), 50);
      });

      const native = await getNativeModule();
      if (!native) {
        throw new Error('åŸç”Ÿæ¨¡å—ä¸å¯ç”¨');
      }

      this.addLog('åŸç”Ÿæ¨¡å—å·²å°±ç»ª');
      this.connectionStep = 'æ­£åœ¨è¿æ¥åˆ°è¿œç¨‹æ¡Œé¢';
      
      // å†æ¬¡ç¡®ä¿UIæ›´æ–°
      await new Promise<void>((resolve) => {
        setTimeout(() => resolve(), 50);
      });

      // è°ƒç”¨åŸç”Ÿè¿æ¥æ–¹æ³•ï¼ˆåœ¨åå°æ‰§è¡Œï¼Œé¿å…é˜»å¡UIï¼‰
      this.addLog('è°ƒç”¨åŸç”Ÿè¿æ¥æ¥å£...');
      
      // ä½¿ç”¨ Promise åŒ…è£…åŒæ­¥è°ƒç”¨ï¼Œé¿å…é˜»å¡UIçº¿ç¨‹
      const result = await new Promise<number>((resolve) => {
        // ä½¿ç”¨ setTimeout å°†åŒæ­¥è°ƒç”¨ç§»åˆ°ä¸‹ä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œè®©UIæœ‰æ—¶é—´æ›´æ–°
        setTimeout(() => {
          try {
            const connectResult = native.connect(this.deskId, this.password ?? '');
            resolve(connectResult);
          } catch (error) {
            console.error('[Session] Connect error:', error);
            resolve(-1);
          }
        }, 100);
      });

      this.addLog(`è¿æ¥è¿”å›ç»“æœ: ${result}`);

      if (result === 0) {
        this.isConnected = true;
        this.connectionStatus = 'å·²è¿æ¥';
        this.connectionStep = 'è¿æ¥æˆåŠŸ';
        this.addLog('âœ“ è¿æ¥æˆåŠŸ');
        this.addLog('å¯åŠ¨è§†é¢‘æµ...');
        this.startVideoStream();
      } else {
        this.isConnected = false;
        this.connectionStatus = 'è¿æ¥å¤±è´¥';
        this.connectionStep = 'è¿æ¥å¤±è´¥';
        this.errorMessage = `è¿æ¥å¤±è´¥ (é”™è¯¯ç : ${result})`;
        this.addLog(`âœ— è¿æ¥å¤±è´¥ï¼Œé”™è¯¯ç : ${result}`);
        this.addLog('è¯·æ£€æŸ¥ï¼š');
        this.addLog('1. è®¾å¤‡ ID æ˜¯å¦æ­£ç¡®');
        this.addLog('2. è¿œç¨‹è®¾å¤‡æ˜¯å¦åœ¨çº¿');
        this.addLog('3. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸');
        this.addLog('4. å¯†ç æ˜¯å¦æ­£ç¡®ï¼ˆå¦‚æœéœ€è¦ï¼‰');
      }
    } catch (error) {
      this.isConnected = false;
      this.connectionStatus = 'è¿æ¥é”™è¯¯';
      this.connectionStep = 'å‘ç”Ÿé”™è¯¯';
      const errorMsg = error instanceof Error ? error.message : String(error);
      this.errorMessage = `è¿æ¥é”™è¯¯: ${errorMsg}`;
      this.addLog(`âœ— è¿æ¥å¼‚å¸¸: ${errorMsg}`);
    }
  }

  private async disconnect(): Promise<void> {
    try {
      if (this.videoTimer !== -1) {
        clearInterval(this.videoTimer);
        this.videoTimer = -1;
      }
      if (this.isConnected) {
        const native = await getNativeModule();
        if (native) {
          native.disconnect();
        }
      }
      this.isConnected = false;
      this.connectionStatus = 'æœªè¿æ¥';
      this.errorMessage = '';
    } catch (error) {
      this.errorMessage = `æ–­å¼€è¿æ¥é”™è¯¯: ${error}`;
    }
  }

  private startVideoStream(): void {
    if (this.videoTimer !== -1) {
      clearInterval(this.videoTimer);
    }
    const interval = Math.max(50, 1000 / this.frameRate);
    this.videoTimer = setInterval(async () => {
      await this.fetchVideoFrame();
    }, interval);
  }

  private async fetchVideoFrame(): Promise<void> {
    if (!this.isConnected) {
      return;
    }
    try {
      const native = await getNativeModule();
      if (!native) {
        return;
      }
      const frame = native.getVideoFrame();
      if (frame && frame.data) {
        await this.convertToPixelMap(frame);
      }
    } catch (error) {
      this.errorMessage = `ç”»é¢è·å–å¤±è´¥: ${error}`;
    }
  }

  private async convertToPixelMap(frame: VideoFrame) {
    try {
      const imageInfo: image.ImageInfo = {
        size: { width: frame.width, height: frame.height },
        pixelFormat: image.PixelMapFormat.RGBA_8888,
        alphaType: image.AlphaType.OPAQUE,
        density: 0,
        stride: 0,
        mimeType: '',
        isHdr: false
      };
      const opts: image.InitializationOptions = {
        size: imageInfo.size,
        pixelFormat: imageInfo.pixelFormat,
        editable: true,
      };
      const next = await image.createPixelMap(frame.data, opts);
      if (this.pixelMap) {
        this.pixelMap.release();
      }
      this.pixelMap = next;
    } catch (error) {
      this.errorMessage = `è§£ç å¤±è´¥: ${error.message ?? error}`;
    }
  }
}
